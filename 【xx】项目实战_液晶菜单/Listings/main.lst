C51 COMPILER V9.01   MAIN                                                                  04/11/2022 01:47:05 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\KEILC51\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) OBJECT
                    -(.\Objects\main.obj)

line level    source

   1          /*********************************************************************
   2           * 实验名称：   EC11+1602液晶简易多级菜单实验
   3           * 选配书籍：   上册-《深入浅出STC8增强型51单片机进阶攻略》2022已出版
   4                                                                  下册-《深入浅出STC8增强型51单片机实战攻略》还在写作
   5           * 书籍作者：   龙顺宇编著 清华大学出版社出版
   6           * 淘宝店铺：   https://520mcu.taobao.com/
   7           * 实验平台：   思修电子STC8“战将”系列小王子开发板
   8           * 芯片型号：   STC8H8K64U-LQFP64（程序微调后可移植至STC其他系列单片机）
   9           * 时钟说明：   片内IRC高速24MHz时钟，使用STC-ISP下载程序时配置
  10           * 实验说明：   先断电后操作，连接07-EB、06-EA、05-EC短路帽，插装1602字符
  11           液晶模块（注意1脚位置，切莫插反或插错），检查无误后给开发板上电，做好ST
  12           C-ISP配置并下载程序。
  13           液晶第一行显示：
  14           液晶第二行显示：
  15           EC11左右旋转选择要执行的功能（线程）
  16           EC11单击后进入该线程，此时页面显示执行线程的线程函数名称，并且执行线程函数。再次单机EC11。返回选择页面。
  17           注意： EC11_B 接到 P3^2引脚！！！   EC11_C 接到 P3^3引脚 
  18          *********************************************************************/
  19          #include        "STC8H.h"       //主控芯片的头文件
  20          #include    "stdio.h"
  21          #include    "stdlib.h"
  22          /***************************常用数据类型定义*************************/
  23          #define u8  uint8_t
  24          #define u16 uint16_t
  25          #define u32 uint32_t
  26          typedef unsigned char  uint8_t;
  27          typedef unsigned int   uint16_t;
  28          typedef unsigned long  uint32_t;
  29          /***************************端口/引脚定义区域************************/
  30          sbit EC11_B=P0^7;       //EC11的B引脚（脉冲）
  31          sbit EC11_A=P3^2;       //EC11的A引脚（脉冲）             EC11_B 接到 P3^2引脚 启用INT0外部下降沿中断
  32          sbit EC11_C=P3^3;       //EC11的E引脚（内部按键）        启用INT1外部下降沿中断
  33          sbit LCDRS=P7^4;                //LCD1602数据/命令选择端口
  34          sbit LCDEN=P7^6;                //LCD1602使能信号端口
  35          sbit LCDRW=P7^5;    //LCD1602读写控制端口
  36          #define LCDDATA  P2     //LCD1602数据端口DB0至DB7
  37          /***************************用户自定义数据区域***********************/
  38          #define Max_Index 3 
  39          #define Min_Index 1
  40          //#define NULL (void *)0
  41          
  42          int  List_Index = 2;    //液晶主菜单索引
  43          int  List_Flag = 0;     //索引标志 1则可以进入选项 0则只停留在菜单选择
  44          
  45          /* 定义线程结构体 */
  46          typedef struct Thread{
  47                  int PID;                                        //进程号
  48                  char name[17];                          //显示内容
  49                  void (*Thread_Fun)(void);       //线程函数
  50                  struct Thread *Next;
  51          }Thread,*PThread;
  52          
  53          PThread g_pThread = NULL; //链表头节点
  54          
C51 COMPILER V9.01   MAIN                                                                  04/11/2022 01:47:05 PAGE 2   

  55          /*****************************函数声明区域***************************/
  56          void delay(u16 Count);                  //延时函数
  57          void LCD1602_Write(u8 cmdordata,u8 writetype);
  58          //写入液晶模组命令或数据函数
  59          void LCD1602_Init(void);       //液晶初始化函数
  60          void LCD1602_Dis_Line(char *str, int y);                //1602行显示函数
  61          
  62          void OS_Init(void);                               //液晶显示菜单框架初始化
  63          void Register_Threads(void);              //线程登记函数
  64          void Thread_List(PThread ptThread);       //线程链表函数
  65          PThread Thread_Index(int Index);          //线程索引函数
  66          
  67          void Thread_one(void);                          //线程1函数
  68          void Thread_two(void);                          //线程2函数
  69          void Thread_three(void);                        //线程3函数
  70          void Thread_four(void);                         //线程4函数
  71          /***************************调试接口***********************/
  72          #define SYSCLK 24000000UL               //系统时钟频率值
  73          #define BAUD_SET  (65536-SYSCLK/9600/4)//波特率设定与计算 
  74          /*****************************函数声明区域***************************/                                                             
  75          void UART1_Init(void);                  //串口1初始化函数
  76          void U1SEND_C(u8 SEND_C);               //串口1发送单字符数据函数
  77          char putchar(char ch);                  //发送字符重定向函数
  78          /******************************主函数区域****************************/
  79          void main(void)
  80          {
  81   1              PThread ptThread = NULL;
  82   1      
  83   1              OS_Init();
  84   1      
  85   1      
  86   1              printf("--------------------------------------\r\n");
  87   1              printf("【UART1】:MOD1 24MHz 9600bps\r\n");     
  88   1              printf("【UART1】:RXD/P3.0, TXD/P3.1\r\n");     
  89   1              printf("--------------------------------------\r\n");
  90   1      
  91   1              while(1)
  92   1              {
  93   2                      
  94   2                      printf("List_Index = %d\n",List_Index); 
  95   2                      ptThread =      Thread_Index(List_Index);       
  96   2      
  97   2                      
  98   2                      if(List_Flag)       //EC11按下 执行当前选择线程的线程函数
  99   2                      {
 100   3                              ptThread->Thread_Fun();
 101   3                              List_Index = 1;  //退出线程函数后 从线程1开始选择
 102   3                      }
 103   2                      
 104   2                      LCD1602_Dis_Line(ptThread->name,1); //刷新显示
 105   2              }       
 106   1      }
 107          
 108          void OS_Init(void)
 109          {
 110   1              //配置P7.4-6为准双向/弱上拉模式
 111   1              P7M0&=0x8F;                             //P7M0.4-6=0
 112   1              P7M1&=0x8F;                             //P7M1.4-6=0
 113   1              //配置P2为准双向/弱上拉模式
 114   1              P2M0=0x00;                              //P2M0.0-7=0
 115   1              P2M1=0x00;                              //P2M1.0-7=0
 116   1              //配置P0.5-7为准双向/弱上拉模式
C51 COMPILER V9.01   MAIN                                                                  04/11/2022 01:47:05 PAGE 3   

 117   1              P0M0&=0x1F;                             //P0M0.5-7=0
 118   1              P0M1&=0x1F;                             //P0M1.5-7=0
 119   1              delay(5);                                       //等待I/O模式配置稳定
 120   1              //使能P3^2 P3^3的外部中断
 121   1              
 122   1              IT1 = 1; //使能 INT1 下降沿中断
 123   1              EX1 = 1; //使能 INT1 中断
 124   1              EA = 1;   //打开总中断
 125   1      
 126   1              LCDRW=0;                //因只涉及写入操作，故将RW引脚直接置低
 127   1              UART1_Init();                                   //初始化串口1
 128   1              LCD1602_Init();         //LCD1602初始化
 129   1              LCD1602_Dis_Line(" Mode selection ",0);
 130   1              LCD1602_Dis_Line("--    MODE    --",1);
 131   1              List_Index = 1;
 132   1              printf("List_Index = %d\n",List_Index);
 133   1              delay(5);
 134   1              printf("List_Index = %d\n",List_Index); 
 135   1              Register_Threads();
 136   1              printf("List_Index = %d\n",List_Index); 
 137   1              
 138   1              IT0 = 1;  //使能INT0下降沿中断
 139   1              EX0 = 1;  //使能INT0中断
 140   1      
 141   1      }
 142          /*
 143                  线程索引
 144          */
 145          PThread Thread_Index(int Index)
 146          {
 147   1              PThread ptTmp = g_pThread;
 148   1              while(ptTmp)
 149   1              {
 150   2                      if(ptTmp->PID == Index) 
 151   2                              return ptTmp;
 152   2                      ptTmp = ptTmp->Next;
 153   2              }
 154   1              return NULL;
 155   1      }
 156          /*
 157                  线程初始化 
 158          struct Thread tThread1 = {
 159          //              .PID = 1,
 160          //              .name = "--  thread_1x  --",
 161          //              .Thread = Thread_one,
 162          //};
 163          //可以用该方法乱序赋值结构体，奈何编译器版本太老会报错
 164          
 165          /*
 166                  线程登记          注意！！线程4不可用，用来填充链表头
 167          */
 168          void Register_Threads(void)
 169          {
 170   1              Thread tThread4 = {4, "--             --", Thread_four};
 171   1              Thread tThread2 = {2, "--  thread_2  --", Thread_two};
 172   1              Thread tThread3 = {3, "--  thread_3  --", Thread_three};
 173   1              Thread tThread1 = {1, "--  thread_1  --", Thread_one};  
 174   1              
 175   1              Thread_List(&tThread4);
 176   1              Thread_List(&tThread3);
 177   1              Thread_List(&tThread2);
 178   1              Thread_List(&tThread1);
C51 COMPILER V9.01   MAIN                                                                  04/11/2022 01:47:05 PAGE 4   

 179   1              
 180   1      
 181   1      }
 182          
 183          /*
 184                  线程链表建立 头插法
 185          */
 186          void Thread_List(PThread ptThread)
 187          {
 188   1              ptThread->Next = g_pThread;
 189   1              g_pThread = ptThread;
 190   1      }
 191          /*
 192                  线程函数建立模板
 193          */
 194          void Thread_one(void)
 195          {
 196   1              while(1)
 197   1              {
 198   2                      LCD1602_Dis_Line("--  run  one  --",1);
 199   2                      if(!List_Flag) return; //退出该线程     
 200   2              }
 201   1      }
 202          
 203          void Thread_two(void)
 204          {
 205   1              while(1)
 206   1              {
 207   2                      LCD1602_Dis_Line("--  run  two  --",1);
 208   2                      if(!List_Flag) return; //退出该线程             
 209   2              }
 210   1      }
 211          
 212          void Thread_three(void)
 213          {
 214   1              while(1)
 215   1              {
 216   2                      LCD1602_Dis_Line("-- run three  --",1);
 217   2                      if(!List_Flag) return; //退出该线程             
 218   2              }
 219   1      }
 220          
 221          void Thread_four(void) 
 222          {
 223   1              while(1)
 224   1              {
 225   2                      LCD1602_Dis_Line("-- run four  --",1);
 226   2                      if(!List_Flag) return; //退出该线程             
 227   2              }
 228   1      }
 229          
 230          
 231          /********************************************************************/
 232          //延时函数delay(u16 Count)，有形参Count,无返回值
 233          /********************************************************************/
 234          void delay(u16 Count)
 235          {
 236   1        u8 i,j;
 237   1        while (Count--)//Count形参控制延时次数
 238   1        {
 239   2          for(i=0;i<50;i++)
 240   2            for(j=0;j<20;j++);
C51 COMPILER V9.01   MAIN                                                                  04/11/2022 01:47:05 PAGE 5   

 241   2        }
 242   1      }
 243          /********************************************************************/
 244          //写入液晶模组命令或数据函数LCD1602_Write()，有形参cmdordata和
 245          //writetype，无返回值。
 246          /********************************************************************/
 247          void LCD1602_Write(u8 cmdordata,u8 writetype)
 248          {
 249   1        if(writetype==0)              //判断写入类型
 250   1          LCDRS=0;                                    //写入命令信息
 251   1        else
 252   1          LCDRS=1;                                    //写入数据信息
 253   1        LCDDATA=cmdordata;    //向数据线端口写入信息
 254   1        delay(5);                                             //延时等待稳定
 255   1        LCDEN=1;                                              //模块使能
 256   1        delay(5);                                             //延时等待写入
 257   1        LCDEN=0;                                              //模块不使能
 258   1      }
 259          /********************************************************************/
 260          //LCD1602初始化函数LCD1602_init()，无形参和返回值
 261          /********************************************************************/
 262          void LCD1602_Init(void)
 263          {
 264   1        LCD1602_Write(0x38,0);        //配置16*2显示，5*7点阵，8位数据接口
 265   1        LCD1602_Write(0x0C,0);        //设置开显示，不显示光标
 266   1        LCD1602_Write(0x06,0);        //写字符后地址自动加1
 267   1        LCD1602_Write(0x01,0);        //显示清0，数据指针清0
 268   1      }
 269          /********************************************************************/
 270          //显示字符函数LCD1602_Dis_Line(char *str, int y)，
 271          //有形参: str 要显示的字符串  y要显示在液晶的哪一行 0或1  0第一行 1第二行
 272          //表示液晶菜单的索引，无返回值
 273          /********************************************************************/
 274          void LCD1602_Dis_Line(char *str, int y)
 275          {
 276   1        u8 i;                                                                 //定义控制循环变量i
 277   1        if(!y)
 278   1        LCD1602_Write(0x80,0);//选择第一行
 279   1        else LCD1602_Write(0xC0,0);  //第二行
 280   1        delay(5);                                                     //等待液晶显示稳定
 281   1        for(i=0;i<16;i++)                     //第一行先写入15个字符
 282   1        {
 283   2                      LCD1602_Write(str[i],1);                //写入菜单项内容
 284   2                      delay(5);                                               //等待液晶显示稳定
 285   2        }
 286   1      }
 287          
 288          /********************************************************************/
 289          //串口1初始化函数UART1_Init()，无形参，无返回值
 290          /********************************************************************/
 291          void UART1_Init(void)
 292          {
 293   1              SCON=0x50;                      //181结构，可变波特率，允许数据接收
 294   1              AUXR|=0x01;                     //串口1选择定时器2为波特率发生器
 295   1              AUXR|=0x04;                     //定时器时钟1T模式
 296   1              T2L=BAUD_SET;           //设置定时初始值
 297   1              T2H=BAUD_SET>>8;//设置定时初始值
 298   1              AUXR|=0x10;                     //定时器2开始计时
 299   1              RI=0;TI=0;                      //清除接收数据标志位和发送数据标志位
 300   1      }
 301          /********************************************************************/
 302          //串口1发送单字符数据函数U1SEND_C()，有形参SEND_C即为欲发送单字节
C51 COMPILER V9.01   MAIN                                                                  04/11/2022 01:47:05 PAGE 6   

 303          //数据，无返回值
 304          /********************************************************************/
 305          void U1SEND_C(u8 SEND_C)
 306          {
 307   1              TI=0;                                           //清除发送完成标志位
 308   1              SBUF=SEND_C;            //发送数据
 309   1              while(!TI);                     //等待数据发送完成
 310   1      }
 311          /********************************************************************/
 312          //发送字符重定向函数char putchar(char ch)，有形参ch，有返回值ch
 313          /********************************************************************/
 314          char putchar(char ch)
 315          {
 316   1              U1SEND_C((u8)ch);//通过串口1发送数据
 317   1              return ch;
 318   1      }
 319          
 320          
 321          /* EC11 旋钮中断函数 */
 322          void INT0_Isr(void) interrupt 0
 323          {
 324   1      
 325   1              if(EC11_B==1)                                           //若EC11_B引脚为高电平
 326   1                      {
 327   2                              if(List_Index<Max_Index)List_Index+=1;
 328   2                              else  List_Index = Max_Index;
 329   2                      }                                               //判定“右旋”行为
 330   1              else
 331   1                      {
 332   2                              if(List_Index > Min_Index)List_Index-=1;
 333   2                              else  List_Index = Min_Index;
 334   2                      }                                               //判定“左旋”行为
 335   1      }
 336          
 337          /* EC11 按键中断函数 */
 338          void INT1_Isr() interrupt 2
 339          {
 340   1              unsigned int i = 0;
 341   1              
 342   1              if(EC11_C==0)                                           //内部按键确定按下
 343   1              {
 344   2                      delay(20);
 345   2                      if(EC11_C==0)
 346   2                      { 
 347   3                              List_Flag = !List_Flag;                         //判定为单击行为                    
 348   3                              while(EC11_C==0);       //等待按键第二次松手
 349   3                      }
 350   2              }
 351   1      }
 352          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    988    ----
   CONSTANT SIZE    =    321    ----
   XDATA SIZE       =      7     112
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
